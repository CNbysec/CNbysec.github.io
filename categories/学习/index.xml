<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on </title>
    <link>/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 02 Sep 2024 20:06:21 +0800</lastBuildDate>
    <atom:link href="/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>比较有意思的几个漏洞挖掘记录</title>
      <link>/%E6%AF%94%E8%BE%83%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 02 Sep 2024 20:06:21 +0800</pubDate>
      <guid>/%E6%AF%94%E8%BE%83%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%AE%B0%E5%BD%95/</guid>
      <description>转载自： https://forum.butian.net/share/3692&#xA;sql 注入 某条数据，点击详情的数据包，单引号报错&#xA;再加一个正常&#xA;本以为是一次平平无奇的 sql 注入，没想到绕了一天才绕过去，下面放几张测试失败的截图&#xA;首先就是 404，不知道规则是啥样的，下面语句应该是没问题的就会 404,1=1 让语句不通就会 500&#xA;试了下 orcale 的注入方法，又爆 403，这里&amp;rsquo;||55||&amp;lsquo;会返回空数据，&amp;rsquo;||1/0||&amp;lsquo;会爆 500，这里判断语句能想到的都试了，全 403，最奇怪的是只有语句正确才会 403，少写一个 D 就会 500，不知道这什么匹配逻辑，不过试了一些插入空白字符啥的也都不行&#xA;这里我又跑了一遍字典，全 404、500、403，期间尝试结合分块传输、参数污染、垃圾数据、白名单、高并发均未绕过去&#xA;最终经过我的不断测试,插入下面 payload 回显特别慢，最终显示数据量太大，不过 in 这个关键字我理解的不是很透彻，有懂的师傅可以解答下&#xA;1 &amp;#39;OR+1+in+1+and+&amp;#39;a&amp;#39;+in+&amp;#39;a 当 1 in 5 的时候整个结果为 false，返回为空&#xA;直接注下 user 的长度&#xA;1 &amp;#39;OR+1+in+length(user)+and+&amp;#39;a&amp;#39;+in+&amp;#39;a 只有相等时会卡死，很明显为 7 位&#xA;直接用 instr 函数注用户名&#xA;1 2 3 4 5 6 &amp;#39;OR+1+in+instr(user,&amp;#39;u&amp;#39;)+and+&amp;#39;a&amp;#39;+in+&amp;#39;a instr函数代表后面那个字符在前面字符串第一次出现的位置 例如: instr(&amp;#39;user&amp;#39;,&amp;#39;u&amp;#39;)返回1 instr(&amp;#39;user&amp;#39;,&amp;#39;us&amp;#39;)返回1 instr(&amp;#39;user&amp;#39;,&amp;#39;s&amp;#39;)返回2 第一位为 S&#xA;第二位为 H，其他同理&#xA;任意用户名密码重置 玩的某个游戏，手机号换了，申诉成功给我发了邮件，可以看到 id 和 token</description>
    </item>
    <item>
      <title>一次经典教育系统后台漏洞打包</title>
      <link>/%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%85%B8%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%8F%B0%E6%BC%8F%E6%B4%9E%E6%89%93%E5%8C%85/</link>
      <pubDate>Mon, 02 Sep 2024 18:34:17 +0800</pubDate>
      <guid>/%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%85%B8%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%8F%B0%E6%BC%8F%E6%B4%9E%E6%89%93%E5%8C%85/</guid>
      <description>转载自： https://forum.butian.net/share/3693&#xA;记:一次经典教育系统后台漏洞打包! 前言: 小编认为像什么什么大学比较显眼的 &amp;ldquo;统一认证登录&amp;rdquo;||&amp;ldquo;学生综合管理&amp;rdquo;,基本上弱口令是不太行,别的漏洞的话好多也都被大佬们打完了或者利用上不太容易(菜鸟的内心崩塌)，对于自己渗透能力的有限，信息收集就尤为重要! 既然主站打不了，就打旁站吧！（基本的方式都是通用的） 这里先分享一下小编自用的谷歌语法：谷歌语法基础的符号： “xxx”: 将要搜索的关键字用引号括起来 (表示完全匹配，即关键词不能分开，顺序也不能变)&#xA;例如：腾讯课堂如果不加“ ”的话，就会针对腾讯和课堂进行拆分，既对腾讯进行搜索也对课堂进行搜索，所以加上“ ”的话就会对腾讯课堂进行绑定，只对腾讯课堂进行搜索&#xA;+：“xxx” +baidu.com&#xA;搜索 xxx 与 baidu.com 相关的内容&#xA;例如：腾讯课堂 +ke.qq.com，那么这里就会显示 ke.qq.com 相关的内容&#xA;-：“xxx” -baidu.com&#xA;搜索结果里面除去 baidu.com 相关的内容&#xA;例如：腾讯课堂 -ke.qq.com，这里再搜索的时候，就会把这个网址屏蔽掉&#xA;谷歌语法的基础使用 在渗透测试的过程中，运用谷歌语法能快速地帮我们找到可能存在漏洞的页面&#xA;谷歌语法常用搜索参数： site： 指定域名，如：site:edu.cn 搜索教育网站&#xA;inurl： 用于搜索包含的 url 关键词的网页，如：inurl:uploads 文件上传，搜索关于公司有关的网址中含有 login 的网页，&#xA;intitle： 搜索网页标题中的关键字，如：&#xA;intitle:“index of /admin” robots.txt&#xA;intitle:“robots.txt”&#xA;intext： 搜索网页正文中的关键字，如：intext:登陆/注册/用户名/密码&#xA;filetype： 按指定文件类型即文件后缀名搜索，如：filetpye:php/asp/jsp&#xA;cache： 已经删除的缓存网页，推荐组合使用&#xA;谷歌语法拓展 查找后台 site:xx.com intext:管理|后台|登陆|用户名|密码|系统|帐号|admin|login|sys|managetem|password|username&#xA;site:xx.com inurl:login|admin|manage|member|admin_login|login_admin|system|login|user&#xA;查找 sql 注入漏洞 inurl:.php?id=23 公司</description>
    </item>
    <item>
      <title>教育行业渗透打点</title>
      <link>/%E6%95%99%E8%82%B2%E8%A1%8C%E4%B8%9A%E6%B8%97%E9%80%8F%E6%89%93%E7%82%B9/</link>
      <pubDate>Sun, 28 Jul 2024 18:23:14 +0800</pubDate>
      <guid>/%E6%95%99%E8%82%B2%E8%A1%8C%E4%B8%9A%E6%B8%97%E9%80%8F%E6%89%93%E7%82%B9/</guid>
      <description>转载自： https://forum.butian.net/share/2423&#xA;1、OA系统密码找回 找回密码 系统使用说明文档中发现登录账号 600030 密码找回，找回方式选择密保问题 问题选择出生地，密保问题答案填写高校所在地 即可修改密码 修改密码，即可以图文信息&amp;hellip;&#xA;1、OA系统密码找回 找回密码 系统使用说明文档中发现登录账号 600030&#xA;密码找回，找回方式选择密保问题&#xA;问题选择出生地，密保问题答案填写高校所在地&#xA;即可修改密码&#xA;修改密码，即可以图文信息中心的身份登录OA系统&#xA;在文件中找到1400多名学生的敏感信息文件，其中存在手机号、身份证号、学号，可以组合密码本进行统一身份认证系统的爆破登录，默认密码为身份证后六位&#xA;成功登录一部分账号&#xA;登录VPN 进行内网扫描，利用MS17010拿下C段多台主机权限&#xA;钓鱼 利用OA系统的通讯功能，散播木马&#xA;获取多台机器权限&#xA;2、逻辑漏洞修改密码 GitHub密码泄漏 GitHub泄漏学号密码&#xA;但账号已被禁用&#xA;获取学号手机号 存在注册功能的网站注册用户，然后登录&#xA;通过以下接口获得用户ID /User/GetUserListByKeyWord&#xA;可以通过以下接口遍历用户ID，获取任意用户的姓名 手机号 邮箱等敏感信息&#xA;/User/Tip?time61&amp;amp;id=caec35e7-9956-4f68-98bc-e2aee73ebda5&amp;amp;_=1664438691592&#xA;获取多组学号、姓名、手机号&#xA;修改密码 点击同意门户的忘记密码功能，输入上面得到的学号&#xA;输入手机号，点击获取验证码并抓包&#xA;记录回包内容&#xA;1 &amp;#34;datas&amp;#34;:&amp;#34;{\&amp;#34;sign\&amp;#34;:\&amp;#34;407ec6dc275f4766a4525e059a60ca16\&amp;#34;}&amp;#34;,&amp;#34;code&amp;#34;:&amp;#34;0&amp;#34;,&amp;#34;message&amp;#34;:&amp;#34;获取成功&amp;#34; 随意输入验证码，点击下一步，并把上面的流量包直接返回&#xA;可以看到页面跳转到了设置密码&#xA;成功更改密码&#xA;79个应用，通过其中一个aspx站SQL注入拿到shell&#xA;3、Github泄漏账号密码 账号密码 1、GitHub搜索&amp;quot;学校域名&amp;quot; &amp;ldquo;password&amp;rdquo; 发现邮箱账号密码&#xA;2、登录邮箱发现手机号身份证号&#xA;统一门户 3、手机号加邮箱密码直接登录统一门户&#xA;泛微OA 跳转到泛微OA,文件上传GetShell&#xA;4、向日葵密码读取 heapdump文件泄漏 直接下载heapdump文件&#xA;读取到mssql账号密码&#xA;向日葵密码读取 成功连接mssql服务器，执行xp_cmdshell&#xA;C:\Program Files\Oray\SunLogin\SunloginClient\config.ini为向日葵的默认安装配置文件，直接尝试读取&#xA;fastcode将第一位字母去除就为本机识别码，encry_pwd为加密后的本机验证码&#xA;可以使用GitHub解密项目https://github.com/wafinfo/Sunflower_get_Password进行解密。&#xA;解密后成功连接目标主机服务器</description>
    </item>
    <item>
      <title>验证码渗透最全总结</title>
      <link>/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%B8%97%E9%80%8F%E6%9C%80%E5%85%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 20 May 2024 17:55:46 +0800</pubDate>
      <guid>/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%B8%97%E9%80%8F%E6%9C%80%E5%85%A8%E6%80%BB%E7%BB%93/</guid>
      <description>转载自： https://forum.butian.net/share/2602&#xA;验证码渗透最全总结 不少人在碰见验证码的时候，大多数只是看了一眼就过去了，没想到验证码还有啥可测试的。但其实验证码也能在项目中导致高危,并且验证码漏洞能在一定情况下造成危害。&#xA;验证码总结 验证码分为两块内容，一块是图形验证码，一块是短信验证码。下面是对这些技巧总结的思维导图。&#xA;图形验证码 图形验证码长宽可控 简单测试方法，就是看到一个登录框，然后新建打开图片链接，在图片链接中就有机会看到两个参数值，一个是 width，一个是 length。这两个参数是计算图片验证码的长宽，如果长宽过高就会过度消耗的是服务器的 CPU 资源。&#xA;当length为比较大的时候，响应时间为2767millis&#xA;注意：该漏洞能造成服务器拒绝服务攻击。有的 SRC 里面注明了，禁止使用 DDOS 攻击，这种漏洞是不收的，如果提交了漏洞，很有可能面临法律责任。&#xA;图形验证码可绕过 有时候开发，会写两套图形验证码流程，一套是在生产运行阶段必须使用正确验证码才能通过服务器校验。另外一套是在测试 SIT 环境下，把验证码设置为只要是 null 或者是空都可以登录验证码置为空，提高开发工作效率。还有的时候，将验证码修改为 true 就好了。这个是因为开发在进行图形验证码判断的时候，只要是验证码收到的是 true 就会通过。具体测试过程已经找不到了，大概写一下吧。&#xA;图形验证码不失效 简单易懂，图形验证码没有对应的失效机制。导致图形验证码能被多次利用。图形验证码在使用后未失效，发送短信时抓包，发送到Repeter中进行重放，可以发送成功!&#xA;图形验证码可识别 这个就是开发在制作图形验证码功能的时候，没有将图形验证码加入足够多的噪点，使验证码能够被现有的工具进行识别。一般是项目硬凑数用的，SRC 全部都不收。具体不做解释&#xA;图形验证码随机值可控 都知道图形验证码是后端随机生成的。那么随机生成的时候，有没有可能是能控制这个随机值？有可能! 生成验证码的随机值被写在了 url 里面&#xA;将characters固定为aaaa，可以看到图形验证码为aaaa&#xA;图形验证码返回到前端 测试过程已经找不到了，口头描述下大致就是登录后会在响应包中返回了下次图形验证码的内容。&#xA;短信验证码 我们已经写完了图形验证码部分，现实情况下短信验证码也是比较多。短信验证码的漏洞技巧要比图形验证码多很多&#xA;短信炸弹纵向 在一个限制时间的情况下对一个手机号，发送的短信验证码条数超过发送预期，这种漏洞我们都称为短信炸弹or短信轰炸or短信炸弹纵向&#xA;不停点击repeter或者放到intruder里面，就可以实现一个手机号接收到多条短信&#xA;短信炸弹横向 上面我们提到了在限定时间内，对一个手机号发送超过预期的短信条数是短信轰炸。造成的结果就是浪费短信资源。如果开发把这个漏洞给改了，那么还有没有漏洞？还有？不能给一个人发送短信验证了，那么给其他人发送验证码一样的。&#xA;将phone设置成变量，进行遍历&#xA;短信验证码可爆破 我们讲了 2 个发送短信验证码，都知道验证码通常 4 位数或者 6 位数的数字验证码。如果服务器没有限制提交的验证码的次数，那么我们可以爆破这个验证码。并且如果有 4 位验证码被爆破成功的话，在 SRC 里面通常是按照高危处理。&#xA;短信验证码可编辑 我们讲了发送短信验证码以及爆破短信验证码。我们知道短信验证码功能发送的是短信，那么我们就有可能把短信内容给更改。&#xA;通过修改transAmt 参数内容，可随意修改短信内容&#xA;短信炸弹的绕过技巧 我们在了解基础短信验证码的漏洞后，相应的开发也会进行了解。那么我们就需要增加技巧来绕过这些东西。&#xA;短信炸弹的绕过技巧 1&amp;ndash;特殊字符 通常，开发在发送短信验证码的时候，没有对特殊字符进行过滤。比如在手机号是 15312341234。我们加上+86，变成+8615312341234，这样的话服务器就有可能判定为两个手机号了。</description>
    </item>
    <item>
      <title>万字总结信息收集全网最全</title>
      <link>/%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8/</link>
      <pubDate>Fri, 26 Apr 2024 18:19:39 +0800</pubDate>
      <guid>/%E4%B8%87%E5%AD%97%E6%80%BB%E7%BB%93%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8/</guid>
      <description>转载自： https://forum.butian.net/share/2841&#xA;万字吐血总结信息收集&#xA;一、信息收集前言&#xA;二、域名信息&#xA;1、Whois查询&#xA;1.1、站长之家&#xA;1.2、爱站&#xA;1.3、微步&#xA;1.4、国外的who.is&#xA;1.5、阿里云域名信息查询&#xA;1.6、腾讯查询&#xA;1.7、中国互联网信息中心&#xA;2、ICP(Internet Content Provider)备案查询&#xA;2.1、国家企业信用信息公示系统&#xA;2.2、ICP备案查询网&#xA;2.3、ICP备案查询 - 站长工具&#xA;2.4、天眼查&#xA;2.5、企查查&#xA;3、SEO(Search Engine Optimization)查询&#xA;3.1、爱站-SEO综合查询&#xA;3.2、站长-SEO综合查询&#xA;4、历史漏洞&#xA;4.1、乌云漏洞库&#xA;5、Google Hacking&#xA;5.1、intext:后台管理&#xA;5.2、intitle：管理登录&#xA;5.3、filetype:pdf&#xA;5.4、inurl: php?id=&#xA;5.5、site：baidu.com&#xA;5.6、filetype：pdf site:baidu.com&#xA;6、Github&#xA;7、维基和百度百科&#xA;8、网络空间搜索引擎&#xA;8.1、Fofa&#xA;8.2、Shodan&#xA;8.3、Zoomeye(钟馗之眼)&#xA;8.4、Spyse&#xA;8.5、Censys&#xA;9、REG007&#xA;二、APP、小程序、公众号信息收集&#xA;1、APP信息搜集&#xA;1.1、七麦数据&#xA;1.2、AppStore(安卓和IOS)&#xA;2、微信公众号和小程序&#xA;4、logo&#xA;5、favicon.ico&#xA;三、子域名收集(挖掘)&#xA;1、SSL(HTTPS)证书&#xA;1.1、大厂商SSL证书一证多用&#xA;1.2、HTTPS证书错误泄露域名&#xA;1.3、在线网站证书查询&#xA;2、网络深度爬虫&#xA;3、域传送漏洞&#xA;3.1、常用DNS记录&#xA;3.2、DNS区域传送&#xA;3.3、域传送漏洞&#xA;3.4、检测&#xA;4、在线DNS数据&#xA;4.1、VirusTotal</description>
    </item>
    <item>
      <title>支付类漏洞挖掘技巧总结</title>
      <link>/%E6%94%AF%E4%BB%98%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 22 Mar 2024 18:22:32 +0800</pubDate>
      <guid>/%E6%94%AF%E4%BB%98%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid>
      <description>转载自： https://forum.butian.net/share/2778&#xA;前言： 支付类逻辑漏洞在漏洞挖掘中是常常出现的问题之一。此类漏洞挖掘思路多，奖励高，是炙手可热的漏洞。此篇文章主要围绕挖掘支付逻辑漏洞时的一些思路分享。&#xA;支付逻辑漏洞成因： 支付漏洞可能由以下原因造成：&#xA;前端验证不充分：在前端页面上，没有进行足够的验证和限制，使得用户可以通过修改页面元素或发送自定义请求来篡改支付金额、支付类型、支付状态等。 客户端数据不可信：客户端（如移动应用）在进行支付时，没有对传输的数据进行完整性验证和加密，导致恶意用户可以直接修改数据包中的支付金额、订单号等与订单有关的参数。 服务器端验证不严格：支付请求在到达服务器端时，没有进行足够的验证和校验，使得攻击者能够更改支付相关参数并绕过服务器端的验证机制。 不安全的存储和传输：支付金额数据在存储或传输过程中未经适当的加密保护，导致黑客可以窃取或篡改数据。 支付逻辑漏洞挖掘技巧： 在实际漏洞挖掘中，一般最先尝试的就是更改数据包发包内容，可以直接修改支付金额、更改支付状态、更改支付类型、更改提交订单支付的时候其中的订单信息等等，当然也会有一些新奇的功能点可以测试。这些在测试中会遇到的操作可以分为以下几类：&#xA;一、更改支付金额 在支付流程中，可以修改支付价格的步骤有很多，包括订购、确认信息、付款等。在涉及到价格的步骤中都可以尝试修改，如果网站在某一环节存在逻辑上的漏洞，就可以利用该漏洞对支付价格进行修改。可以直接修改提交订单中的价格字段，一般可尝试0.01，1.00，1等&#xA;二、更改支付状态 在测试中有的时候订单得支付状态是由用户提交订单时的某个数据包参数决定的，服务端通过支付状态判断订单支付与否，这时我们可以尝试找到这个参数（可以通过正常支付订单的数据包进行对比），对支付状态进行修改。或者还有一种情况是通过检查订单是否支付，这个时候可以通过抓取已支付的订单数据包将其中的订单编号改为未支付的编号，实现绕过。&#xA;1、直接修改为已支付状态&#xA;2、修改未支付的订单号为已支付订单号&#xA;三、修改支付类型 通常在提交订单付款时，这里的type一般是对支付方式的判断，可能会存在开发人员测试的时候遗留的无需支付的type值，根据支付方式判断支付与否。可以通过fuzz特定值去实现绕过。比如比较常见的值0（这里需要结合实际进行测试不同的处理方式type值不同），可以实现不需要付款订单就会自动生成。&#xA;四、更改订单信息 服务端只检查支付是否完成，并没有确认订单金额与银行支付金额是否相同，过分信任客户端提交的数据。此时可以通过替换支付订单号、更换商品id的方式，来完成花少钱买更贵的东西。同时生成两个订单号，一个贵的一个便宜，首先支付便宜的，银行往回返回的时候，替换订单号，然后就可以完成两个订单的同时支付。&#xA;常见位置在生成订单、生成支付链接等。&#xA;1、修改商品编号&#xA;直接在生成的订单中替换商品编号。&#xA;2、修改订单号&#xA;将金额不同的订单进行替换，可以支付一个金额较少的订单，然后将订单号修改为金额较大的订单，少付实际金额。&#xA;3、越权使用他人优惠券、越权使用他人积分等&#xA;五、更改数量实现优惠支付 支付金额是由购买数量乘以商品单价决定的，这时我们在数据包中修改购买数量，将其修改为负数或者小数，如果站点后台对此没有进行过滤，就有可能存在支付漏洞。&#xA;1、将正常的数量值修改至最小值0.01，可以实现低价购买。比如：原价300修改修量为0.01后实付金额变为3。&#xA;2、未对负数做检验的还可以将数量改为负数。（这里需要注意，因为后端大部分会校验不允许实付金额小于0或者0.01等，所以有的时候要想实现订单成功生成需要结合实际修改价格）&#xA;生成订单时有参数表示商品数量，修改为-1&#xA;修改数量为-1后会发现，此时金额为负数。&#xA;在提交订单支付的时候，为保证支付成功需要修改金额。&#xA;3、对数量没有做负数校验的时候也可以巧用负数抵消实现0元购&#xA;在计算价格时，没有对负数进行验证，通过修改某个商品数量为-1实现与1的抵消实现0元购。&#xA;同时购买两件商品，修改两件商品其中价格低的商品的金额为负数，实现价格的抵消，低价购买商品。&#xA;4、手动增加订单中商品相关的多个参数以达到少付多买的目的。&#xA;有的时候在提交订单时抓取数据包可以看到只有一套商品的信息，尝试多添加几套同样的参数订单是否会有变化。&#xA;尝试在提交订单的时候多添加几个此类参数&#xA;提交订单实际支付金额未变仍是一个商品的价格，但是实际套餐已经变成了四个。&#xA;六、重复支付，突破限购 在支付系统中，服务端没有做好相关验证，比如订单状态被错误更新或者未更新，未对订单多重提交进行校验。那么就可以并发订单实现优惠订单多次提交。需要注意的是这里有的时候会根据实际支付订单判断，并发了多个订单也可能只有一个优惠订单可以正常支付。&#xA;并发订单，多台设备同时提交优惠订单。&#xA;常见于限购，一个账号仅许购买一次等&#xA;1、限制一个优惠订单时直接并发生成多个优惠订单&#xA;2、使用多台设备、多个浏览器、多种支付方式（wx、支付宝等）购买优惠订单&#xA;常见于购买会员，会员第一个月往往会有优惠价。生成一个优惠订单后不支付，打开多个设备或者虚拟器设备，同时提交生成优惠订单，再分别支付，有的时候会发现会员截至日期顺延，突破限制以优惠价格购买会员。&#xA;3、退款处并发。退款的时候可以发起同一订单多次退款，达到多退款的目的。&#xA;七、优惠券多次使用 常见于涉及优惠券的订单中。可以在提交订单的时候修改发包中优惠券的值尝试使用大额优惠券，或者按照原数据包中优惠券的构造参数手工添加几张优惠券，达到优惠券叠用的目的。有优惠券面值参数的也可以直接修改数据包中优惠券的面值。&#xA;1、在一个订单中叠加使用优惠券&#xA;2、修改优惠券标识，尝试使用其他商品中的大额优惠券&#xA;3、直接修改优惠券的面值。实际金额计算会扣除优惠的部分，此时修改优惠券面值可以实现低价购买。&#xA;八、遍历隐藏或者下架优惠id获取优惠链接 漏洞常见位置：会员处、商品处（隐藏商品，已下架商品，开发测试低价商品等）&#xA;1、遍历隐藏优惠券&#xA;一般会有一些开发时测试的大额优惠券，或者已经过期下架的优惠券，通过遍历可以被使用。&#xA;2、遍历商品id从而fuzz到已下架的商品&#xA;九、利用小数点精度四舍五入 0.019=0.02（比如充值0.019元，第三方支付截取到分也就是0.01元，但是系统四舍五入为0.02）。</description>
    </item>
    <item>
      <title>攻防实战外网突破</title>
      <link>/%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E5%A4%96%E7%BD%91%E7%AA%81%E7%A0%B4/</link>
      <pubDate>Sun, 11 Feb 2024 18:24:29 +0800</pubDate>
      <guid>/%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E5%A4%96%E7%BD%91%E7%AA%81%E7%A0%B4/</guid>
      <description>转载自： https://forum.butian.net/share/2442&#xA;在经历了多年的攻防对抗之后，大量目标单位逐渐认识到安全防护的重要性。因此，他们已采取措施尽可能收敛资产暴露面，并加倍部署各种安全设备。但安全防护注重全面性，具有明显的短板&amp;hellip;&#xA;1、供应链 在经历了多年的攻防对抗之后，大量目标单位逐渐认识到安全防护的重要性。因此，他们已采取措施尽可能收敛资产暴露面，并加倍部署各种安全设备。但安全防护注重全面性，具有明显的短板效应，一处出现短板，整个防护体系就可能瞬间崩溃。而目标单位的供应链往往是这些薄弱点的集中体现。这些供应链不仅暴露在外，而且由于复杂的关系，使得对它们的监控和管理变得更为困难。因此，攻击团队通常会选择从供应链着手，以一种迂回的方式绕过目标单位强大的防御体系，获得对目标单位的控制权限。&#xA;通过在搜索引擎上搜索&amp;quot;系统名称&amp;quot;目标单位&#xA;找到相关的供应商信息，通过对供应商进行攻击，获取目标单位的数据及权限。!&#xA;1.1、heapdump泄露 通过对供应商资产进行渗透，发现某资产admin目录下存在heapdump文件泄露&#xA;对于heapdump的利用方式这里就不太赘述，有许多文章对其原理和利用都进行了深入的研究，特定情况下还可以直接进行RCE，这里泄露了大量敏感信息，密码信息加入密码本&#xA;登录MinIO，发现大量所属目标单位的敏感信息，也存在其它单位的敏感信息&#xA;登录Nacos，大量配置文件，密码信息加入密码本![]&#xA;登录OSS，发现大量所属目标单位的敏感信息&#xA;1.2、微信小程序接口未授权 1.2.1、微信小程序解包 想要对微信小程序进行解包操作，首先是要获取目标小程序的wxapkg文件。wxapkg文件是微信小程序的安装包文件格式，用于将小程序的代码、资源以及其他必要的文件打包成一个单独的文件。但是Windows环境下的wxapkg文件中的js代码和资源文件一般是被加密的，需要使用专门设计的解密工具先进行解密，再进行解包操作，获取文件内容。iOS和Android平台下可直接进行解包操作。&#xA;1.2.1.1、获取wxapkg文件 在获取wxapkg文件时，最好将文件夹中的文件先删除，然后再重新打开小程序，防止其它文件干扰&#xA;iOS wxapkg 文件存放路径为：&#xA;1 /var/mobile/Containers/Data/Application/{系统UUID}/Library/WechatPrivate/{user哈希值}/WeApp/LocalCache/release/{小程序的AppID} Android wxapkg 文件存放路径为：&#xA;1 /data/data/com.tencent.mm/MicroMsg/{user哈希值}/appbrand/pkg/ Windows wxapkg 文件存放路径为：&#xA;1 C:\Users\{系统用户名}\Documents\WeChat Files\Applet\{小程序的AppID}\ 1.2.1.2、解密操作 下面两个github项目都可以进行解密操作&#xA;https://github.com/superdashu/pc_wxapkg_decrypt_python&#xA;https://github.com/BlackTrace/pc_wxapkg_decrypt&#xA;解密原理&#xA;成功解密&#xA;1.2.1.2、解包操作 国光大佬提供的工具下载链接&#xA;https://sqlsec.lanzoub.com/i1NEP0mx694f&#xA;1 node wuWxapkg.js 1.wxapkg 对小程序进行解包操作，获取到前端JS代码后中，从中进行提取获得接口&#xA;直接访问目标接口，前端页面虽然显示初始化失败&#xA;但流量包中已获取数据，近千万条目标单位敏感信息&#xA;1.3、web程序越权 通过上述收集到的密码，撞密码撞出一个账号，但是此账号为最低权限，无任何操作权限，点击搜索组织架构，此时无任何返回信息&#xA;抓包将parentId和orgLevel去除，再发包，即可越权看到全员组织架构&#xA;点击修改密码，然后将上述获取到的roleId添加进去，即可获取全部权限&#xA;获取到大量数据&#xA;1.4、公众号 js泄露密码，密码可撞库目标单位公众号&#xA;2、云原生安全 容器化部署和微服务架构为应用程序开发和部署提供了更好的灵活性、可伸缩性、可维护性和性能，受到了越来越多厂商的使用，新的应用就会引入新的攻击面，如容器逃逸、服务间攻击、API滥用等。攻击者可以利用这些新的入口点来攻击应用程序和数据。并且在云原生环境下管理用户和服务的身份验证和授权变得更加复杂。许多应用开发商在追求容器化和云原生架构的便利性和效率时，安全性常常被忽视或放在次要位置。这就直接导致了云原生环境的脆弱，容易受到各种安全威胁和攻击。&#xA;2.1、Harbor 镜像仓库 Harbor是一个开源的容器镜像仓库管理器，旨在帮助组织存储、管理和分发Docker容器镜像，但是Harbor存在一个充满争议的“漏洞”：任意用户能够直接获取public的镜像。&#xA;可以直接拉取下载镜像文件，可以利用脚本批量下载&#xA;2.2、疑似后门 通过镜像文件获取jar包，获取配置文件等敏感信息，对jar包的class文件进行反编译，进行代码审计获取到一个类似后门的漏洞，该接口只需要使用用户名，即可登录系统后台。管理员权限配合文件上传获取服务器权限。&#xA;通过配置文件连接数据库等&#xA;2.3、docker未授权 2.3.1、 registry api未授权访问 在 Docker Registry API 中，认证和授权通常是基于访问令牌（Access Token）或者用户名和密码的。如果未正确设置访问控制权限，即会造成未授权访问漏洞，攻击者可直接下载registry仓库的所有镜像容器。</description>
    </item>
    <item>
      <title>任意用户登录漏洞挖掘思路</title>
      <link>/%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Sat, 20 Jan 2024 18:17:14 +0800</pubDate>
      <guid>/%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF/</guid>
      <description>转载自： https://forum.butian.net/share/2553&#xA;任意用户登录漏洞挖掘思路 前言 任意用户登录漏洞以利用漏洞利用难度低、危害高、奖金高已经成为src/众测漏洞挖掘中的香饽饽，本文将分享一下众测/src中任意用户登录漏洞的挖掘思路。&#xA;1.手机验证码问题导致的任意用户登录 1.1 验证码爆破 当登录流程使用手机验证码登录，没有图片验证码/图片验证码可重用/图片验证码简单可识别（可以使用captcha-killer-modified插件）且后端没有限制手机验证码验证错误次数时，可以尝试爆破手机验证码登录其他用户。&#xA;4位验证码的爆破老生常谈不再赘述；随着厂商们服务器性能的提高，服务器的rps的上升也使得6位验证码的爆破越来越快，可以使用如下方法爆破（！！！需留意服务器的rps以及测试厂商的注意事项，rps低的老系统或者厂商禁止批量爆破的项目谨慎使用6位验证码的爆破！！！）：&#xA;使用burpsuite的Turbo Intruder插件，编写如下脚本：&#xA;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import re def queueRequests(target, wordlists): engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=30, pipeline=True ) for i in range(1000000): #生成六位验证码字典 number = &amp;#34;{:06d}&amp;#34;.format(i) engine.queue(target.req, number.rstrip()) def handleResponse(req, interesting): # currently available attributes are req.status, req.wordcount, req.length and req.response if req.status &amp;lt;404: &amp;#39;&amp;#39;&amp;#39;res = re.</description>
    </item>
    <item>
      <title>SRC混子的漏洞挖掘之道</title>
      <link>/src%E6%B7%B7%E5%AD%90%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B9%8B%E9%81%93/</link>
      <pubDate>Thu, 30 Nov 2023 09:06:55 +0800</pubDate>
      <guid>/src%E6%B7%B7%E5%AD%90%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B9%8B%E9%81%93/</guid>
      <description>转载自： https://xz.aliyun.com/t/8501&#xA;一个SRC混子挖SRC的半年经验分享~,基本都是文字阐述，希望能给同样在挖洞的师傅们带来一点新收获。&#xA;前期信息收集 还是那句老话,渗透测试的本质是信息收集，对于没有0day的弱鸡选手来说，挖SRC感觉更像是对企业的资产梳理，我们往往需要花很长的时间去做信息收集，收集与此公司相关的信息，包括企业的分公司，全资子公司，网站域名、手机app,微信小程序，企业专利品牌信息，企业邮箱，电话等等，对于很多万人挖的src来说，你收集到了别人没有收集过的资产，往往离挖到漏洞就不远了。&#xA;企业相关信息收集 企查查 (https://www.qcc.com）/)&#xA;天眼查(https://www.tianyancha.com/)&#xA;启信宝（https://www.qixin.com/)&#xA;企查查、天眼查淘宝都有那种一天的会员。对于我们信息收集其实已经够用，个人更喜欢用企查查，因为它能一键导出域名，还可以直接查看企业关联的子公司，比较方便。&#xA;主要查询的信息:&#xA;一般大的src都有许多子公司,企查查可以在所属集团中查看该集团下子公司，并且可以导出。 查看同电话企业基本都是子公司。 查看股份穿透图，一般来说控股超过50%的子公司的漏洞SRC收录的可能性都比较大。 查看企业下的app、小程序、还有品牌的资产，直接在搜索引擎里搜索品牌可能会有意想不到的收获。（找到一些平常收集不到的资产) PS:一般来说100%的全资子公司src漏洞是一定会收的，其他子公司资产可能需要与src审核沟通（扯皮)。&#xA;站长之家:http://whois.chinaz.com/ 邮箱反查、注册人反查、电话反查。 推荐个项目:https://github.com/code-scan/BroDomain 兄弟域名查询。 https://www.qimai.cn/ 七麦数据，可以查到企业下一些比较冷门的app。 信息整理&#xA;当我们通过各种手段对挖掘的企业进行信息收集后，我们大致能得到以下有用的信息&#xA;主公司及分公司、子公司下所有归属的网站域名信息； 主公司及分公司、子公司下所有的专利品牌和开发的一些独立系统。 主公司及分公司、子公司下所有的app资产和微信小程序。 之后我们需要对这些信息进行归纳和整理,比如哪些是该公司的主资产，哪些是边缘资产，哪些资产看上去比较冷门，我们是可以重点关注和进行深入挖掘的。&#xA;子域名收集和网站信息收集 子域名的话，对于我来说oneforall和xray的功能已经足够强大了，对于一些主域名来说，如果想要充分的收集子域名，最好用特大号字典进行最少三层的子域名爆破。这块还是layer子域名挖掘机不错。&#xA;通过github收集子域名 先分享一个姿势，很多时候github上已经有热心的师傅分享了自己跑出的子域名，所以可以先到github找一找有没有现成的可以白嫖，没啥好语法，纯靠大海捞针。。&#xA;oneforAll https://github.com/shmilylty/OneForAll&#xA;需要到配置文件里填写api接口信息， 根据需求修改其他的配置，比如可以配置一些常见的端口，当做简单的端口扫描工具用。 命令&#xA;1 2 python oneforall.py --targets ./domain.txt run python oneforall.py --targets ./domain.txt --brute true run 我实际操作发现在挂了外网代理和没挂代理时跑出来的子域有时候差的有点大，想收集的全一点的师傅可以不挂代理和挂代理都跑一遍。然后去重一下。&#xA;xray 子域名探测需要高级版，可以自己写个十几行的代码进行批量探测，也可以直接用这个项目里的代码，&#xA;https://github.com/timwhitez/rad-xray 命令改一下能批量探测子域名，一般5到10分钟一个子域。&#xA;Goby 官网:https://gobies.org/&#xA;因为之前一直在用masscan+nmap的方式进行端口扫描，用这个项目:https://github.com/hellogoldsnakeman/masnmapscan-V1.0&#xA;1 前一段时间接触到goby，感觉可视化的工具用起来还是舒服，可以短时间对一些常见端口进行扫描，还能对网站进行指纹识别，报告看起来挺舒服的。 因为在实际的端口扫描过程，由于cdn或者防火墙的原因，所以没必要一上来就全端口扫描，听一位师傅分享的经验，比如当扫描到22端口开放时，说明这个ip没有cdn保护，对于这种ip我们可以提取出来，然后重点进行全端口扫描，有收获的可能性会比较大。&#xA;BBScan 猪猪侠师傅写的工具，速度很快，简单的目录扫描，主要是可以探测C段下面的很多资产，扩充攻击面。&#xA;项目地址:&#xA;https://github.com/lijiejie/BBScan&#xA;https://github.com/yhy0/BBScan （添加了springboot的泄露探测）</description>
    </item>
    <item>
      <title>绕waf系列之绕安全狗</title>
      <link>/%E7%BB%95waf%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%95%E5%AE%89%E5%85%A8%E7%8B%97/</link>
      <pubDate>Tue, 15 Dec 2020 21:18:35 +0800</pubDate>
      <guid>/%E7%BB%95waf%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%95%E5%AE%89%E5%85%A8%E7%8B%97/</guid>
      <description>转载自： 网络&#xA;攻击的特定: 攻击二象性:已知攻击和未知攻击&#xA;目前市面主流的WAF产品: 云WAF 阿里云盾 腾讯网站管家 创宇盾 ClodeFlare等 软件产品类 安全狗 云锁 360主机卫士 ModSecurity 硬件类型设备: 启明星辰 绿盟 天融信 飞塔等 硬件waf缺陷:对HTTP协议的兼容性不强,对异常报文会产生bug,导致绕过&#xA;WAF的核心原理: 运用黑白思想 特征匹配,漏洞签名:特定特征的漏洞,比如stract2漏洞 对匹配结果进行响应(拦截,记录) WAF的几种部署模式: 基于DNS解析 修改DNS,让域名解析到反向代理服务器,所有流量经过反向代理进行检测,检测无问题之后再转发给后端的web服务器&#xA;串联模式 一般指的是反向代理模式,透明代理模式.反向代理模式会改变原有的网络拓扑,真实客户端ip会以HTTP header传递给后端web server.透明代理模式可以在不改变原有网络拓扑结构的情况下直接部署. 旁路模式 利用流量镜像技术,将业务流量分流给WAF产品,这种部署模式的优点是不会影响业务稳定性,所以WAF会投入更多的性能在检出率上面.但是缺点也很明显,不借助其他手段无法对检测出的攻击行为进行阻断. 软件嵌入中间件+检测引擎模式 在使用nginx作为反向代理的业务中,WAF提高nginx模块嵌入原有nginx,将请求转发给检测引擎,可以做到在不改动原有的网络拓扑的情况下完成检测任务 WAF为什么会被绕过: 鱼(安全)和熊掌(业务性能)不能兼得,waf需要满足基本业务需求,所以一般不设置白名单之类的过于苛刻的操作 WAF为了考虑通用性的问题,无法100%覆盖某些语言,中间件,数据库等特性 硬件WAF自身往往存在漏洞 架构:waf部署模式 规则缺陷/特性 协议:指HTTP0.9协议:TCP长连接 WAF绕过实战—-绕过安全狗进行注入 所谓的bypass waf实际上是去寻找位于waf设备之后处理应用层数据包的硬件/软件的特性,利用特性构造waf不能命中,但是在应用程序能够执行成功的payload,绕过防护&#xA;实验环境: 环境:安全狗Apache最新版 本地测试代码(PHP):&#xA;1 2 3 4 5 6 7 8 9 10 11 $id = $_GET[&amp;#39;id&amp;#39;]; $con = mysql_connect(&amp;#34;localhost&amp;#34;,&amp;#34;root&amp;#34;,&amp;#34;root&amp;#34;); if (!$con){die(&amp;#39;Could not connect: &amp;#39; .</description>
    </item>
  </channel>
</rss>
